/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/commands.ts":
/*!*************************!*\
  !*** ./src/commands.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Commands: () => (/* binding */ Commands),\n/* harmony export */   CreatePlayer: () => (/* binding */ CreatePlayer),\n/* harmony export */   MovePlayer: () => (/* binding */ MovePlayer),\n/* harmony export */   TheFirst: () => (/* binding */ TheFirst),\n/* harmony export */   getInstanceFromEnum: () => (/* binding */ getInstanceFromEnum)\n/* harmony export */ });\n/* harmony import */ var _ecs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ecs */ \"./src/ecs.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components */ \"./src/components.ts\");\n\n\n\n// order in which they get executed\nvar Commands;\n(function (Commands) {\n    Commands[Commands[\"TheFirst\"] = 0] = \"TheFirst\";\n    Commands[Commands[\"CreatePlayer\"] = 1] = \"CreatePlayer\";\n    Commands[Commands[\"MovePlayer\"] = 2] = \"MovePlayer\";\n    //    SetEntityElementsPositionAndDisplayElement = 3,\n    //    SendComputedElementsToRender = 4,\n    //    CreateShadows = 5,\n    //    WatchDevBox = 6,\n    //    RemoveShadows = 7,\n    //    PlayAnimations = 8,\n    //    UpdateShadowNumber = 9,\n    //    UpdateShadowProperties = 10,\n    //    TickTimer = 11,\n    //    UpdateAnimationTimerNumber = 12,\n    //    CreateAnimationTimers = 13,\n    //    MoveCameraWithPlayer = 14,\n    //    CreateDog = 15,\n    //    MoveDog = 16,\n    Commands[Commands[\"ApplyForce\"] = 3] = \"ApplyForce\";\n    Commands[Commands[\"Collide\"] = 4] = \"Collide\";\n})(Commands || (Commands = {}));\nfunction getInstanceFromEnum(commandEnum) {\n    switch (commandEnum) {\n        case Commands.TheFirst:\n            return new TheFirst();\n        //        case Commands.MoveCameraWithPlayer:\n        //            return new MoveCameraWithPlayer()\n        //\n        case Commands.Collide:\n            return new Collide();\n        case Commands.ApplyForce:\n            return new ApplyForce();\n        //\n        //        case Commands.MoveDog:\n        //            return new MoveDog()\n        //\n        //        case Commands.CreateDog:\n        //            return new CreateDog()\n        //\n        //        case Commands.UpdateAnimationTimerNumber:\n        //            return new UpdateAnimationTimerNumber()\n        //\n        //        case Commands.TickTimer:\n        //            return new TickTimer()\n        //\n        //        case Commands.CreateAnimationTimers:\n        //            return new CreateAnimationTimers()\n        //\n        //        case Commands.UpdateShadowProperties:\n        //            return new UpdateShadowProperties()\n        //\n        //        case Commands.PlayAnimations:\n        //            return new PlayAnimations()\n        //\n        //        case Commands.UpdateShadowNumber:\n        //            return new UpdateShadowNumber()\n        //\n        //        case Commands.RemoveShadows:\n        //            return new RemoveShadows()\n        //\n        //        case Commands.WatchDevBox:\n        //            return new WatchDevBox()\n        //\n        case Commands.CreatePlayer:\n            return new CreatePlayer();\n        //\n        case Commands.MovePlayer:\n            return new MovePlayer();\n        //\n        //        case Commands.SetEntityElementsPositionAndDisplayElement:\n        //            return new SetEntityElementsPositionAndDisplayElement()\n        //\n        //        case Commands.SendComputedElementsToRender:\n        //            return new SendComputedElementsToRender()\n        //\n        //        case Commands.CreateShadows:\n        //            return new CreateShadows()\n    }\n}\n// the first\nclass TheFirst {\n    constructor() {\n        this.type = Commands.TheFirst;\n    }\n    run(system, _) {\n        // how to ensure they are created in a good order\n        //\n        // first ensure that commands\n        // that depend of some components are created first\n        //\n        system.addCommand(Commands.CreatePlayer);\n        //system.addCommand(Commands.CreateDog)\n        //system.addCommand(Commands.SetEntityElementsPositionAndDisplayElement)\n        //system.addCommand(Commands.SendComputedElementsToRender)\n        //system.addCommand(Commands.PlayAnimations)\n        //system.addCommand(Commands.UpdateAnimationTimerNumber)\n        //system.addCommand(Commands.TickTimer)\n        //system.addCommand(Commands.ApplyForce)\n        //system.addCommand(Commands.Collide)\n        //system.addCommand(Commands.WatchDevBox)\n        system.removeCommand(Commands.TheFirst);\n    }\n}\n// create entity\n//export class CreateDog implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.CreateDog\n//    }\n//\n//    run(system: ECS.System) {\n//        for (let x = 0; x < 5; x++) {\n//            let dog = Utils.newUid()\n//            let positionComponent = new Comps.Position(new Utils.Vector3(50 * x + 100, 0, 0), dog)\n//            let forceComponent = new Comps.Force(new Utils.Vector3(0, 0, 0), dog)\n//            let massComponent = new Comps.Mass(2, dog)\n//            let sizeComponent = new Comps.Size(new Utils.Vector3(40, 90, 30), dog)\n//            let entityStateComponent = new Comps.EntityState(new Map([[Comps.EntityStates.Idle, null]]), dog)\n//            let entityTypeComponent = new Comps.EntityType(Comps.EntityTypes.Dog, dog)\n//            let healthComponent = new Comps.Health(10, dog)\n//            let animationComponent = new Comps.Animation([new Anims.PlayerIdle(), new Anims.PlayerRunning()], dog)\n//            let computedElement = new Comps.GraphicProperties(Comps.ElementTypes.Entity, dog)\n//            computedElement.translateX = positionComponent.x\n//            computedElement.translateY = positionComponent.y\n//            computedElement.zIndex = positionComponent.y\n//            computedElement.color = \"#ff0000\"\n//\n//            system.addComponent(massComponent)\n//            system.addComponent(sizeComponent)\n//            system.addComponent(forceComponent)\n//            system.addComponent(healthComponent)\n//            system.addComponent(animationComponent)\n//            system.addComponent(positionComponent)\n//            system.addComponent(entityStateComponent)\n//\n//            system.addComponent(computedElement)\n//            system.addComponent(entityTypeComponent)\n//        }\n//\n//        system.addCommand(Commands.MoveDog)\n//        system.removeCommand(Commands.CreateDog)\n//    }\n//}\nclass CreatePlayer {\n    constructor() {\n        this.type = Commands.CreatePlayer;\n    }\n    run(system, _) {\n        for (let x = 0; x < 1; x++) {\n            for (let y = 0; y < 1; y++) {\n                let player = _utils__WEBPACK_IMPORTED_MODULE_1__.newUid();\n                let positionComponent = new _components__WEBPACK_IMPORTED_MODULE_2__.Position(new _utils__WEBPACK_IMPORTED_MODULE_1__.Vector3(x * 70, y * 70, 0), player);\n                let entityStateComponent = new _components__WEBPACK_IMPORTED_MODULE_2__.EntityState([_components__WEBPACK_IMPORTED_MODULE_2__.EntityStates.Idle], player);\n                let entityTypeComponent = new _components__WEBPACK_IMPORTED_MODULE_2__.EntityType(_components__WEBPACK_IMPORTED_MODULE_2__.EntityTypes.Player, player);\n                let healthComponent = new _components__WEBPACK_IMPORTED_MODULE_2__.Health(10, player);\n                let forceComponent = new _components__WEBPACK_IMPORTED_MODULE_2__.Force(new _utils__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0), player);\n                let massComponent = new _components__WEBPACK_IMPORTED_MODULE_2__.Mass(4, player);\n                let sizeComponent = new _components__WEBPACK_IMPORTED_MODULE_2__.Size(new _utils__WEBPACK_IMPORTED_MODULE_1__.Vector3(40, 90, 30), player);\n                let computedElementComponent = new _components__WEBPACK_IMPORTED_MODULE_2__.ChangedGraphicProperties(_components__WEBPACK_IMPORTED_MODULE_2__.ElementTypes.Entity, player);\n                computedElementComponent.translateX = positionComponent.x;\n                computedElementComponent.translateY = positionComponent.y;\n                computedElementComponent.zIndex = positionComponent.y;\n                system.addComponent(massComponent);\n                system.addComponent(sizeComponent);\n                system.addComponent(forceComponent);\n                system.addComponent(healthComponent);\n                system.addComponent(positionComponent);\n                system.addComponent(entityStateComponent);\n                system.addComponent(computedElementComponent);\n                system.addComponent(entityTypeComponent);\n            }\n        }\n        system.addCommand(Commands.MovePlayer);\n        system.removeCommand(Commands.CreatePlayer);\n    }\n}\n//\n//// movement\nclass MovePlayer {\n    constructor() {\n        this.type = Commands.MovePlayer;\n    }\n    run(system, resources) {\n        let delta = resources.delta.get();\n        if (delta == null)\n            return;\n        //        let acceleration = 0.03\n        //        let forceLimit = 0.5\n        let acceleration = 0.1;\n        let forceLimit = 1;\n        // get playerUid\n        let foundEntityTypeComponents = system.find([_ecs__WEBPACK_IMPORTED_MODULE_0__.Get.All, [_components__WEBPACK_IMPORTED_MODULE_2__.Components.EntityType], _ecs__WEBPACK_IMPORTED_MODULE_0__.By.Any, null]);\n        if (foundEntityTypeComponents[0].length == 0) {\n            console.log(\"no entity types found\");\n            return;\n        }\n        let playerUid = null;\n        for (let fC of foundEntityTypeComponents[0]) {\n            let entityTypeComponent = fC;\n            if (entityTypeComponent.entityType == _components__WEBPACK_IMPORTED_MODULE_2__.EntityTypes.Player) {\n                playerUid = entityTypeComponent.entityUid;\n            }\n        }\n        if (playerUid == null)\n            return;\n        // if was found, move it\n        if (resources.input.movementDirection.x == 0 &&\n            resources.input.movementDirection.y == 0) {\n            let foundEntityState = system.find([\n                _ecs__WEBPACK_IMPORTED_MODULE_0__.Get.All,\n                [\n                    _components__WEBPACK_IMPORTED_MODULE_2__.Components.EntityState,\n                ],\n                _ecs__WEBPACK_IMPORTED_MODULE_0__.By.EntityId,\n                foundEntityTypeComponents[0][0].entityUid\n            ]);\n            if (foundEntityState[0].length == 0) {\n                console.log(\"entityState not found\");\n                return;\n            }\n            for (let fC of foundEntityState[0]) {\n                let entityStateComponent = fC;\n                if (entityStateComponent.entityUid == playerUid) {\n                    // cannot change state to idle if wasnt runnning\n                    let indexOfRun = entityStateComponent.states.indexOf(_components__WEBPACK_IMPORTED_MODULE_2__.EntityStates.Run);\n                    if (indexOfRun != -1) {\n                        entityStateComponent.states.splice(indexOfRun, 1);\n                        if (entityStateComponent.states.includes(_components__WEBPACK_IMPORTED_MODULE_2__.EntityStates.Idle))\n                            return;\n                        entityStateComponent.states.push(_components__WEBPACK_IMPORTED_MODULE_2__.EntityStates.Idle);\n                    }\n                    return;\n                }\n            }\n        }\n        let foundForceComponent = system.find([_ecs__WEBPACK_IMPORTED_MODULE_0__.Get.One, [_components__WEBPACK_IMPORTED_MODULE_2__.Components.Force], _ecs__WEBPACK_IMPORTED_MODULE_0__.By.EntityId, playerUid]);\n        if (foundForceComponent[0].length == 0) {\n            console.log(\"no player force found found\");\n            return;\n        }\n        let forceComponent = foundForceComponent[0][0];\n        let newForce = new _utils__WEBPACK_IMPORTED_MODULE_1__.Vector2(0, 0);\n        newForce.x = forceComponent.x + resources.input.movementDirection.x * acceleration;\n        newForce.y = forceComponent.y + resources.input.movementDirection.y * acceleration;\n        if (Math.abs(newForce.x) > forceLimit) {\n            newForce.x = forceLimit * (newForce.x < 0 ? -1 : 1);\n        }\n        if (Math.abs(newForce.y) > forceLimit) {\n            newForce.y = forceLimit * (newForce.y < 0 ? -1 : 1);\n        }\n        let foundEntityState = system.find([_ecs__WEBPACK_IMPORTED_MODULE_0__.Get.One, [_components__WEBPACK_IMPORTED_MODULE_2__.Components.EntityState], _ecs__WEBPACK_IMPORTED_MODULE_0__.By.EntityId, playerUid]);\n        if (foundEntityState[0].length == 0) {\n            console.log(\"player entityState not found\");\n            return;\n        }\n        let entityStateComponent = foundEntityState[0][0];\n        if (!entityStateComponent.states.includes(_components__WEBPACK_IMPORTED_MODULE_2__.EntityStates.Run)) {\n            entityStateComponent.states.push(_components__WEBPACK_IMPORTED_MODULE_2__.EntityStates.Run);\n        }\n        let indexOfIdle = entityStateComponent.states.indexOf(_components__WEBPACK_IMPORTED_MODULE_2__.EntityStates.Idle);\n        if (indexOfIdle != -1) {\n            entityStateComponent.states.splice(indexOfIdle, 1);\n        }\n        if (resources.input.movementDirection.x != 0) {\n            forceComponent.x = newForce.x;\n        }\n        if (resources.input.movementDirection.y != 0) {\n            forceComponent.y = newForce.y;\n        }\n    }\n}\n//export class MoveDog implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.MoveDog\n//    }\n//\n//    run(system: ECS.System) {\n//\n//        let delta = system.delta()\n//        if (delta == null) return\n//\n//        let acceleration = 0.02\n//        let forceLimit = 1\n//\n//\n//        // get dog and player entityTypes\n//        let foundEntityTypeComponents = system.find([ECS.Get.All, [Comps.Components.EntityType], ECS.By.Any, null])\n//        if (foundEntityTypeComponents[0].length == 0) {\n//            console.log(\"no entity types found\")\n//            return\n//        }\n//\n//\n//        for (let fC of foundEntityTypeComponents[0]) {\n//            // for every dog\n//            let entityTypeComponent = fC.component as Comps.EntityType\n//            if (entityTypeComponent.entityType != Comps.EntityTypes.Dog) {\n//                continue\n//            }\n//\n//            // current dog uid\n//            let dogUid = entityTypeComponent.entityUid\n//\n//            // dog position\n//            let foundDogComponents = system.find(\n//                [ECS.Get.One, [Comps.Components.Position, Comps.Components.TargetLocation, Comps.Components.Force], ECS.By.EntityId, dogUid])\n//            if (foundDogComponents[0].length == 0 || foundDogComponents[2].length == 0) {\n//                console.log(\"no dog component found\")\n//                return\n//            }\n//            let dogPositionComponent = foundDogComponents[0][0].component as Comps.Position\n//            let dogTargetLocationComponent: Comps.TargetLocation | null = null\n//\n//            if (foundDogComponents[1].length != 0) {\n//                dogTargetLocationComponent = foundDogComponents[1][0].component as Comps.TargetLocation\n//            }\n//            // get closest player\n//            let closestPlayerPositionComponent: Comps.Position | null = null\n//            let closestPositionHypothenuse: number | null = null\n//            // loop through players\n//            for (let fETC of foundEntityTypeComponents[0]) {\n//                let entityTypeComponent = fETC.component as Comps.EntityType\n//                if (entityTypeComponent.entityType == Comps.EntityTypes.Player) {\n//\n//                    // get player position\n//                    let foundPlayerPositionComponents = system.find(\n//                        [ECS.Get.One, [Comps.Components.Position], ECS.By.EntityId, fETC.component.entityUid])\n//                    if (foundPlayerPositionComponents[0].length == 0) {\n//                        console.log(\"no player position found\")\n//                        break\n//                    }\n//                    let playerPositionComponent = foundPlayerPositionComponents[0][0].component as Comps.Position\n//\n//                    // calculate closest player\n//                    let side1 = playerPositionComponent.x - dogPositionComponent.x\n//                    let side2 = playerPositionComponent.y - dogPositionComponent.y\n//\n//                    let hypothenuse = Math.hypot(side1, side2)\n//\n//                    // if is the first set to closest\n//                    if (closestPlayerPositionComponent == null) {\n//                        closestPlayerPositionComponent = playerPositionComponent\n//                        closestPositionHypothenuse = hypothenuse\n//                        continue\n//                    }\n//                    if (hypothenuse < closestPositionHypothenuse!) {\n//                        closestPlayerPositionComponent = playerPositionComponent\n//                        closestPositionHypothenuse = hypothenuse\n//                    }\n//                }\n//            }\n//            if (closestPlayerPositionComponent == null) {\n//                console.log(\"no player to follow\")\n//                return\n//            }\n//\n//            let isDogInPlayerRadius = false\n//            let playerRadius = 200\n//            if (playerRadius >= closestPositionHypothenuse!) {\n//                isDogInPlayerRadius = true\n//            }\n//\n//            // follow player\n//            if (!isDogInPlayerRadius) {\n//                if (dogTargetLocationComponent != null) {\n//                    system.setProperty<Comps.TargetLocation, \"x\">\n//                        (foundDogComponents[1][0], \"x\", closestPlayerPositionComponent.x)\n//                    system.setProperty<Comps.TargetLocation, \"y\">\n//                        (foundDogComponents[1][0], \"y\", closestPlayerPositionComponent.y)\n//                } else {\n//                    let newTargetLocation = new Comps.TargetLocation(\n//                        new Utils.Vector2(\n//                            closestPlayerPositionComponent.x,\n//                            closestPlayerPositionComponent.y),\n//                        dogUid)\n//                    system.addComponent(newTargetLocation)\n//                }\n//            }\n//\n//            // random movement\n//            if (isDogInPlayerRadius && Utils.randomNumber(1000) == 10) {\n//                let targetLocation = new Utils.Vector2(0, 0)\n//                if (Utils.randomNumber(2) == 2) {\n//                    targetLocation.x = closestPlayerPositionComponent.x + Utils.randomNumber(playerRadius - 50)\n//                } else {\n//                    targetLocation.x = closestPlayerPositionComponent.x - Utils.randomNumber(playerRadius - 50)\n//                }\n//\n//                if (Utils.randomNumber(2) == 2) {\n//                    targetLocation.y = closestPlayerPositionComponent.y + Utils.randomNumber(playerRadius - 50)\n//                } else {\n//                    targetLocation.y = closestPlayerPositionComponent.y - Utils.randomNumber(playerRadius - 50)\n//                }\n//                if (dogTargetLocationComponent != null) {\n//                    system.setProperty<Comps.TargetLocation, \"x\">\n//                        (foundDogComponents[1][0], \"x\", targetLocation.x)\n//                    system.setProperty<Comps.TargetLocation, \"y\">\n//                        (foundDogComponents[1][0], \"y\", targetLocation.y)\n//                } else {\n//                    let newTargetLocationComponent = new Comps.TargetLocation(\n//                        new Utils.Vector2(\n//                            targetLocation.x,\n//                            targetLocation.y), dogUid)\n//                    system.addComponent(newTargetLocationComponent)\n//                }\n//            }\n//\n//            if (dogTargetLocationComponent == null) continue\n//\n//            let direction = new Utils.Vector2(0, 0)\n//\n//            if ((dogTargetLocationComponent.y - dogPositionComponent.y) > -40) direction.y += 1\n//            if ((dogTargetLocationComponent.y - dogPositionComponent.y) < 40) direction.y -= 1\n//            if ((dogTargetLocationComponent.x - dogPositionComponent.x) > -40) direction.x += 1\n//            if ((dogTargetLocationComponent.x - dogPositionComponent.x) < 40) direction.x -= 1\n//\n//            let forceComponent = foundDogComponents[2][0].component as Comps.Force\n//            let resultDogForce =\n//                new Utils.Vector2(\n//                    forceComponent.x + direction.x * acceleration,\n//                    forceComponent.y + direction.y * acceleration)\n//\n//            if (Math.abs(resultDogForce.x) > forceLimit) {\n//                if (resultDogForce.x < 0) {\n//                    resultDogForce.x = -forceLimit\n//                }\n//                else {\n//                    resultDogForce.x = +forceLimit\n//                }\n//            }\n//            if (Math.abs(resultDogForce.y) > forceLimit) {\n//                if (resultDogForce.y < 0) {\n//                    resultDogForce.y = -forceLimit\n//                }\n//                else {\n//                    resultDogForce.y = +forceLimit\n//                }\n//            }\n//            // check if arrived at target position\n//            if (\n//                Math.abs(dogPositionComponent.x - dogTargetLocationComponent.x) < 1 &&\n//                Math.abs(dogPositionComponent.y - dogTargetLocationComponent.y) < 1\n//            ) {\n//                system.removeComponent(foundDogComponents[1][0])\n//            }\n//\n//            if (resultDogForce.x != 0) {\n//                system.setProperty<Comps.Force, \"x\">(\n//                    foundDogComponents[2][0],\n//                    \"x\",\n//                    resultDogForce.x\n//                )\n//            }\n//            if (resultDogForce.y != 0) {\n//                system.setProperty<Comps.Force, \"y\">(\n//                    foundDogComponents[2][0],\n//                    \"y\",\n//                    resultDogForce.y\n//                )\n//            }\n//\n//        }\n//\n//\n//\n//\n//\n//\n//\n//\n//        //        if (isDogInPlayerRadius) {\n//        //            let foundEntityState = system.find(\n//        //                [\n//        //                    ECS.Get.All,\n//        //                    [\n//        //                        Comps.Components.EntityState,\n//        //                    ],\n//        //                    ECS.By.EntityId,\n//        //                    dogUid\n//        //                ]\n//        //            )\n//        //            if (foundEntityState[0].length == 0) {\n//        //                console.log(\"dog entityState not found\")\n//        //                return\n//        //            }\n//        //\n//        //            let entityStateComponent = foundEntityState[0][0].component as Comps.EntityState\n//        //\n//        //            // cannot change state to idle if wasnt runnning\n//        //            if (entityStateComponent.states.has(Comps.EntityStates.Run)) {\n//        //                system.removeElementFromMapProperty<Comps.EntityState, \"states\">(\n//        //                    foundEntityState[0][0],\n//        //                    \"states\",\n//        //                    Comps.EntityStates.Run\n//        //                )\n//        //\n//        //                if (entityStateComponent.states.has(Comps.EntityStates.Idle)) return\n//        //\n//        //                system.addElementToMapProperty<Comps.EntityState, \"states\">(\n//        //                    foundEntityState[0][0],\n//        //                    \"states\",\n//        //                    new Utils.MapEntry(Comps.EntityStates.Idle, null)\n//        //                )\n//        //            }\n//        //            return\n//        //\n//        //\n//        //        }\n//\n//        // move to desired target position\n//\n//        //        let foundEntityState = system.find(\n//        //            [\n//        //                ECS.Get.All,\n//        //                [\n//        //                    Comps.Components.EntityState,\n//        //                ],\n//        //                ECS.By.EntityId,\n//        //                dogUid\n//        //            ]\n//        //        )\n//        //        if (foundEntityState[0].length == 0) {\n//        //            console.log(\"dog entityState not found\")\n//        //            return\n//        //        }\n//\n//        //  let entityStateComponent = foundEntityState[0][0].component as Comps.EntityState\n//\n//        //  if (!entityStateComponent.states.has(Comps.EntityStates.Run)) {\n//        //      system.addElementToMapProperty<Comps.EntityState, \"states\">(\n//        //          foundEntityState[0][0],\n//        //          \"states\",\n//        //          new Utils.MapEntry(Comps.EntityStates.Run, null)\n//        //      )\n//        //  }\n//        //  if (entityStateComponent.states.has(Comps.EntityStates.Idle)) {\n//        //      system.removeElementFromMapProperty<Comps.EntityState, \"states\">(\n//        //          foundEntityState[0][0],\n//        //          \"states\",\n//        //          Comps.EntityStates.Idle\n//        //      )\n//        //  }\n//    }\n//}\n//\n//// camera\n//export class MoveCameraWithPlayer implements ECS.Command {\n//    // move computed element's position to emulate camera movement\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.MoveCameraWithPlayer\n//    }\n//\n//    run(system: ECS.System) {\n//        let foundComponents = system.find(\n//            [ECS.Get.All, [Comps.Components.ComputedElement], ECS.By.Any, null])\n//\n//        let playerPosition = new Utils.Vector2(0, 0)\n//        for (let cC of system.componentDiffs.changedComponents) {\n//            if (cC.component.type != Comps.Components.Position) continue\n//            let positionComponent = cC.component as Comps.Position\n//            let foundComponents = system.find(\n//                [ECS.Get.All, [Comps.Components.EntityType], ECS.By.Any, null])\n//\n//            let entityTypeComponent = foundComponents[0][0].component as Comps.EntityType\n//            if (entityTypeComponent.entityType == Comps.EntityTypes.Player) {\n//\n//            }\n//        }\n//\n//        //        for (let fC of foundComponents[0]) {\n//        //            let computedElementComponent = fC.component as Comps.ComputedElement\n//        //\n//        //            if (computedElementComponent.entityUid ==\n//        //                positionComponent.entityUid\n//        //            ) {\n//        //                system.setProperty<Comps.ComputedElement, \"translateY\">(\n//        //                    fC, \"translateY\", positionComponent.y - 10)\n//        //                system.setProperty<Comps.ComputedElement, \"isTranslateYChanged\">(\n//        //                    fC, \"isTranslateYChanged\", true)\n//        //\n//        //                system.setProperty<Comps.ComputedElement, \"translateX\">(\n//        //                    fC, \"translateX\", positionComponent.x - 10)\n//        //                system.setProperty<Comps.ComputedElement, \"isTranslateXChanged\">(\n//        //                    fC, \"isTranslateXChanged\", true)\n//        //\n//        //                system.setProperty<Comps.ComputedElement, \"isChanged\">(\n//        //                    fC, \"isChanged\", true)\n//        //                break;\n//        //            }\n//        //        }\n//\n//\n//\n//\n//    }\n//}\n//\n//// computed elements\n//export class SendComputedElementsToRender implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.SendComputedElementsToRender\n//    }\n//\n//    run(system: ECS.System) {\n//        let foundComponents = system.find(\n//            [ECS.Get.All, [Comps.Components.ComputedElement], ECS.By.Any, null])\n//\n//        if (foundComponents[0].length == 0) return\n//\n//        let graphicDiff = new Utils.GraphicDiff()\n//\n//        // for changed\n//        for (let cC of system.componentDiffs.changedComponents) {\n//            if (cC.component.type != Comps.Components.ComputedElement) continue\n//            let computedElementComponent = cC.component as Comps.GraphicProperties\n//\n//            if (!computedElementComponent.isChanged) continue\n//\n//            graphicDiff.changedComputedElements.push(cC)\n//            // set properties to not changed\n//            system.setProperty<Comps.GraphicProperties, \"isChanged\">(\n//                cC, \"isChanged\", false)\n//\n//            if (computedElementComponent.addedClasses.size != 0)\n//                system.removeElementFromMapProperty<Comps.GraphicProperties, \"addedClasses\">(\n//                    cC, \"addedClasses\", null, true)\n//\n//            if (computedElementComponent.removedClasses.size != 0)\n//                system.removeElementFromMapProperty<Comps.GraphicProperties, \"removedClasses\">(\n//                    cC, \"removedClasses\", null, true)\n//\n//            if (computedElementComponent.isTranslateXChanged)\n//                system.setProperty<Comps.GraphicProperties, \"isTranslateXChanged\">(\n//                    cC, \"isTranslateXChanged\", false)\n//            if (computedElementComponent.isTranslateYChanged)\n//                system.setProperty<Comps.GraphicProperties, \"isTranslateYChanged\">(\n//                    cC, \"isTranslateYChanged\", false)\n//            if (computedElementComponent.isZIndexChanged)\n//                system.setProperty<Comps.GraphicProperties, \"isZIndexChanged\">(\n//                    cC, \"isZIndexChanged\", false)\n//            if (computedElementComponent.isColorChanged)\n//                system.setProperty<Comps.GraphicProperties, \"isColorChanged\">(\n//                    cC, \"isColorChanged\", false)\n//            if (computedElementComponent.isDisplayElementChanged)\n//                system.setProperty<Comps.GraphicProperties, \"isDisplayElementChanged\">(\n//                    cC, \"isDisplayElementChanged\", false)\n//        }\n//        // check for new\n//        for (let aC of system.componentDiffs.addedComponents) {\n//            if (aC.component.type == Comps.Components.ComputedElement) {\n//                graphicDiff.addedComputedElements.push(aC)\n//            }\n//\n//        }\n//        // check for removed\n//        for (let rC of system.componentDiffs.removedComponents) {\n//            if (rC.component.type == Comps.Components.ComputedElement) {\n//                graphicDiff.removedComputedElements.push(rC)\n//            }\n//        }\n//\n//        if (graphicDiff.addedComputedElements.length == 0 &&\n//            graphicDiff.removedComputedElements.length == 0 &&\n//            graphicDiff.changedComputedElements.length == 0\n//        ) {\n//            return\n//        }\n//        postMessage(new Utils.Message(Utils.Messages.RenderIt, graphicDiff))\n//    }\n//}\n//\n//// entity elements\n//export class SetEntityElementsPositionAndDisplayElement implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.SetEntityElementsPositionAndDisplayElement\n//    }\n//\n//    run(system: ECS.System) {\n//\n//        let foundComponents =\n//            system.find(\n//                [\n//                    ECS.Get.All,\n//                    [\n//                        Comps.Components.ComputedElement,\n//                    ],\n//                    ECS.By.Any,\n//                    null\n//                ])\n//        // position\n//        for (let cC of system.componentDiffs.changedComponents) {\n//            if (cC.component.type != Comps.Components.Position) continue\n//            let position = cC.component as Comps.Position\n//\n//            for (let fC of foundComponents[0]) {\n//                let computedElement = fC.component as Comps.GraphicProperties\n//\n//                if (computedElement.entityUid ==\n//                    position.entityUid &&\n//                    computedElement.elementType ==\n//                    Comps.ElementTypes.Entity\n//                ) {\n//                    system.setProperty<Comps.GraphicProperties, \"isChanged\">(\n//                        fC, \"isChanged\", true)\n//\n//                    system.setProperty<Comps.GraphicProperties, \"translateY\">(\n//                        fC, \"translateY\", position.y)\n//                    system.setProperty<Comps.GraphicProperties, \"isTranslateYChanged\">(\n//                        fC, \"isTranslateYChanged\", true)\n//\n//                    system.setProperty<Comps.GraphicProperties, \"translateX\">(\n//                        fC, \"translateX\", position.x)\n//                    system.setProperty<Comps.GraphicProperties, \"isTranslateXChanged\">(\n//                        fC, \"isTranslateXChanged\", true)\n//\n//                    system.setProperty<Comps.GraphicProperties, \"zIndex\">(\n//                        fC, \"zIndex\", position.y)\n//                    system.setProperty<Comps.GraphicProperties, \"isZIndexChanged\">(\n//                        fC, \"isZIndexChanged\", true)\n//                    break;\n//                }\n//            }\n//        }\n//\n//        // displayElement\n//        for (let cC of system.componentDiffs.changedComponents) {\n//            if (cC.component.type != Comps.Components.Animation) continue\n//            let animationComponent = cC.component as Comps.Animation\n//\n//            for (let fC of foundComponents[0]) {\n//                let computedElementComponent = fC.component as Comps.GraphicProperties\n//\n//                if (computedElementComponent.entityUid ==\n//                    animationComponent.entityUid &&\n//                    computedElementComponent.elementType ==\n//                    Comps.ElementTypes.Entity\n//                ) {\n//                    system.setProperty<Comps.GraphicProperties, \"isChanged\">(\n//                        fC, \"isChanged\", true)\n//                    system.setProperty<Comps.GraphicProperties, \"displayElement\">(\n//                        fC, \"displayElement\", animationComponent.currentDisplayElement)\n//                    system.setProperty<Comps.GraphicProperties, \"isDisplayElementChanged\">(\n//                        fC, \"isDisplayElementChanged\", true)\n//                    break;\n//                }\n//            }\n//        }\n//    }\n//}\n//\n//// animation\n//export class CreateAnimationTimers implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.CreateAnimationTimers\n//    }\n//\n//    run(system: ECS.System) {\n//\n//        let foundComponents = system.find([\n//            ECS.Get.All,\n//            [\n//                Comps.Components.Animation,\n//            ],\n//            ECS.By.Any,\n//            null\n//        ])\n//        if (foundComponents[0].length == 0) console.log(\"there are not animation components\")\n//        for (let fC of foundComponents[0]) {\n//            let foundComponents = system.find([\n//                ECS.Get.All,\n//                [\n//                    Comps.Components.EntityState,\n//                ],\n//                ECS.By.EntityId,\n//                fC.component.entityUid\n//            ])\n//            if (foundComponents[0].length == 0) {\n//                console.log(\"entityState component missing\")\n//                continue;\n//            }\n//\n//            let entityState = foundComponents[0][0].component as Comps.EntityState\n//            let animation = fC.component as Comps.Animation\n//\n//            let currentStateAnimation: Anims.Animation | null = null;\n//            for (let a of animation.animations) {\n//                if (entityState.states.has(a.executeOn)) {\n//                    currentStateAnimation = a\n//                }\n//            }\n//            if (currentStateAnimation == null) continue\n//\n//            let timer = new Comps.Timer(\n//                currentStateAnimation.frames[currentStateAnimation.frames.length - 1].frameTime,\n//                Comps.TimerTypes.Animation,\n//                entityState.entityUid\n//            )\n//            system.addComponent(timer)\n//            system.setProperty<Comps.Animation, \"currentDisplayElement\">(\n//                foundComponents[0][0], \"currentDisplayElement\", currentStateAnimation.frames[0].frameDisplay\n//            )\n//\n//        }\n//        system.removeCommand(this.type)\n//    }\n//}\n//export class UpdateAnimationTimerNumber implements ECS.Command {\n//    // Creates and deletes animation timers\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.UpdateAnimationTimerNumber\n//    }\n//    run(system: ECS.System) {\n//        // on new graphic entity\n//        for (let aC of system.componentDiffs.addedComponents) {\n//\n//            // get added animation components\n//            if (aC.component.type != Comps.Components.Animation) continue\n//\n//\n//            // get entityState Components\n//            let foundComponents = system.find([\n//                ECS.Get.All,\n//                [\n//                    Comps.Components.EntityState,\n//                ],\n//                ECS.By.EntityId,\n//                aC.component.entityUid\n//            ])\n//            if (foundComponents[0].length == 0) {\n//                console.log(\"entityState component missing\")\n//                continue;\n//            }\n//\n//            let entityStateComponent = foundComponents[0][0].component as Comps.EntityState\n//            let animationAddedComponent = aC.component as Comps.Animation\n//\n//            let currentStateAnimation: Anims.Animation | null = null\n//            let isFirstTime = true\n//            for (let a of animationAddedComponent.animations) {\n//                if (entityStateComponent.states.has(a.executeOn)) {\n//                    if (isFirstTime) {\n//                        currentStateAnimation = a\n//                        isFirstTime = false\n//                        continue;\n//                    }\n//                    if (a.priority > currentStateAnimation!.priority) {\n//                        currentStateAnimation = a\n//                    }\n//                }\n//            }\n//            if (currentStateAnimation == null) continue\n//\n//            let timer = new Comps.Timer(\n//                currentStateAnimation.frames[currentStateAnimation.frames.length - 1].frameTime,\n//                Comps.TimerTypes.Animation,\n//                entityStateComponent.entityUid\n//            )\n//            system.addComponent(timer)\n//            system.setProperty<Comps.Animation, \"currentDisplayElement\">(\n//                foundComponents[0][0], \"currentDisplayElement\", currentStateAnimation.frames[0].frameDisplay!\n//            )\n//            console.log(\"added timer\")\n//        }\n//        // on graphic entity removed\n//        for (let cC of system.componentDiffs.removedComponents) {\n//            if (cC.component.type != Comps.Components.Animation) continue\n//\n//            let foundComponents = system.find([\n//                ECS.Get.All,\n//                [\n//                    Comps.Components.Timer,\n//                ],\n//                ECS.By.EntityId,\n//                cC.component.entityUid\n//            ])\n//            if (foundComponents[0].length == 0) {\n//                console.log(\"timer component missing\")\n//                continue;\n//            }\n//            let timer = foundComponents[0][0].component as Comps.Timer\n//            if (timer.timerType == Comps.TimerTypes.Animation) {\n//                system.removeComponent(foundComponents[0][0])\n//                console.log(\"removed timer\")\n//            }\n//        }\n//    }\n//}\n//export class PlayAnimations implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.PlayAnimations\n//    }\n//\n//    run(system: ECS.System) {\n//        let updatedTimersUid = []\n//\n//        // change animation for entity state change\n//        for (let cC of system.componentDiffs.changedComponents) {\n//            if (cC.component.type != Comps.Components.EntityState) continue\n//\n//            let foundComponents = system.find([\n//                ECS.Get.All,\n//                [Comps.Components.Animation, Comps.Components.Timer],\n//                ECS.By.EntityId,\n//                cC.component.entityUid])\n//            if (foundComponents[0].length == 0) {\n//                console.log(\"animation component missing\")\n//                break;\n//            }\n//\n//            let timer: ECS.ComponentAndIndex | null = null\n//            for (let t of foundComponents[1]) {\n//                if ((t.component as Comps.Timer).timerType == Comps.TimerTypes.Animation) {\n//                    timer = t\n//                }\n//            }\n//            if (timer == null) continue\n//\n//            let animationComponent = foundComponents[0][0].component as Comps.Animation\n//            let entityStateComponent = cC.component as Comps.EntityState\n//\n//            let currentStateAnimation: Anims.Animation | null = null\n//            let isFirstTime = true\n//            for (let a of animationComponent.animations) {\n//                if (entityStateComponent.states.has(a.executeOn)) {\n//                    if (isFirstTime) {\n//                        currentStateAnimation = a\n//                        isFirstTime = false\n//                        continue;\n//                    }\n//                    if (a.priority > currentStateAnimation!.priority) {\n//                        currentStateAnimation = a\n//                    }\n//                }\n//            }\n//            if (currentStateAnimation == null) continue\n//\n//            updatedTimersUid.push(timer.component.componentUid)\n//            system.setProperty<Comps.Timer, \"originalTime\">(\n//                timer,\n//                \"originalTime\",\n//                currentStateAnimation.frames[currentStateAnimation.frames.length - 1].frameTime\n//            )\n//            system.setProperty<Comps.Timer, \"isRestart\">(\n//                timer, \"isRestart\", true)\n//            //            system.setProperty<Comps.Animation, \"currentDisplayElement\">(\n//            //                foundComponents[0][0], \"currentDisplayElement\", currentStateAnimation.frames[0]!)\n//        }\n//\n//        // play next frame\n//\n//        // get animation timers\n//        let foundTimers = system.find(\n//            [ECS.Get.All, [Comps.Components.Timer], ECS.By.Any, null])\n//        if (foundTimers[0].length == 0) {\n//            console.log(\"no timers\")\n//            return;\n//        }\n//        for (let fC of foundTimers[0]) {\n//            // check if is an updated timer\n//            let isFound = false\n//            for (let uT of updatedTimersUid) {\n//                if (fC.component.componentUid == uT) {\n//                    isFound = true\n//                    break;\n//                }\n//            }\n//            if (isFound) continue\n//            // check that are animation timers\n//            let timerComponent = fC.component as Comps.Timer\n//            if (timerComponent.timerType != Comps.TimerTypes.Animation) continue\n//\n//            // if timer is finised restart it \n//            if (timerComponent.isFinished) {\n//                system.setProperty<Comps.Timer, \"isRestart\">(fC, \"isRestart\", true)\n//                continue\n//            }\n//\n//            // get animations and entity states\n//            let foundComponents = system.find(\n//                [ECS.Get.One,\n//                [Comps.Components.Animation, Comps.Components.EntityState],\n//                ECS.By.EntityId,\n//                timerComponent.entityUid])\n//            if (foundComponents[0].length == 0) {\n//                console.log(\"animation component missing\")\n//                break;\n//            }\n//            if (foundComponents[1].length == 0) {\n//                console.log(\"entityState component missing\")\n//                break;\n//            }\n//            let animationComponent = foundComponents[0][0].component as Comps.Animation\n//            let entityStateComponent = foundComponents[1][0].component as Comps.EntityState\n//\n//            // get playing animation based on EntityState\n//            let currentStateAnimation: Anims.Animation | null = null\n//            let isFirstTime = true\n//            for (let a of animationComponent.animations) {\n//                if (entityStateComponent.states.has(a.executeOn)) {\n//                    if (isFirstTime) {\n//                        currentStateAnimation = a\n//                        isFirstTime = false\n//                        continue;\n//                    }\n//                    if (a.priority > currentStateAnimation!.priority) {\n//                        currentStateAnimation = a\n//                    }\n//                }\n//            }\n//            if (currentStateAnimation == null) continue\n//\n//\n//            // get current animation frame\n//            let elapsedTime = timerComponent.originalTime - timerComponent.timeLeft\n//            let currentFrameIndex = 0\n//            for (let [fI, f] of currentStateAnimation.frames.entries()) {\n//                if (f.frameTime > elapsedTime && fI != 0) {\n//                    currentFrameIndex = fI - 1\n//                    break;\n//                }\n//                if (f.isEndFrame) currentFrameIndex = fI - 1\n//            }\n//            if (currentStateAnimation.frames[currentFrameIndex].frameDisplay ==\n//                animationComponent.currentDisplayElement)\n//                continue\n//            // // if already is in this frame\n//            //            if (currentStateAnimation.frames[currentFrameIndex] ==\n//            //                animation.currentDisplayElement)\n//            //                continue\n//            //            console.log(elapsedTime,\n//            //                currentFrameIndex\n//            //                //                currentStateAnimation\n//            //                //                    .frames[currentFrameIndex]!\n//            //                //                    .charCodeAt(0)\n//            //                //                    .toString()\n//            //                //                    .split(\"\")\n//            //                //                    .map((e, i) => { if (i > 2) return e })\n//            //                //                    .join(\"\")\n//            //            )\n//\n//            //currentFrameIndex\n//            //                currentStateAnimation\n//            //                    .frames[currentFrameIndex]!\n//            //                    .charCodeAt(0)\n//            //                    .toString()\n//            //                    .split(\"\")\n//            //                    .map((e, i) => { if (i > 2) return e })\n//            //                    .join(\"\")\n//\n//            system.setProperty<Comps.Animation, \"currentDisplayElement\">(\n//                foundComponents[0][0],\n//                \"currentDisplayElement\",\n//                currentStateAnimation.frames[currentFrameIndex].frameDisplay\n//            )\n//        }\n//    }\n//}\n//\n//// timer\n//export class TickTimer implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.TickTimer\n//    }\n//\n//    run(system: ECS.System) {\n//        let delta = system.delta()\n//        if (delta == null) return\n//\n//        let foundComponents = system.find(\n//            [ECS.Get.All, [Comps.Components.Timer], ECS.By.Any, null])\n//\n//        for (let fC of foundComponents[0]) {\n//            let timer = fC.component as Comps.Timer\n//\n//            if (timer.isRestart) {\n//                system.setProperty<Comps.Timer, \"timeLeft\">(fC, \"timeLeft\", timer.originalTime)\n//                system.setProperty<Comps.Timer, \"isFinished\">(fC, \"isFinished\", false)\n//                system.setProperty<Comps.Timer, \"isRestart\">(fC, \"isRestart\", false)\n//                continue\n//            }\n//\n//            if (timer.isFinished) continue\n//\n//            let newTimeLeft = timer.timeLeft - delta\n//\n//            system.setProperty<Comps.Timer, \"timeLeft\">(fC, \"timeLeft\", newTimeLeft)\n//            if (newTimeLeft <= 0) {\n//                system.setProperty<Comps.Timer, \"isFinished\">(fC, \"isFinished\", true)\n//            }\n//        }\n//    }\n//}\n//\n//// devbox\n//export class WatchDevBox implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.WatchDevBox\n//    }\n//\n//    run(system: ECS.System) {\n//        // Add commands\n//        if (system.devBox.isEnableFreeCamera && !system.getState(\"isEnableFreeCamera\")) {\n//            system.setState(\"isEnableFreeCamera\", true)\n//        }\n//\n//        if (system.devBox.isEnablePhysics && !system.getState(\"isEnablePhysics\")) {\n//            system.setState(\"isEnablePhysics\", true)\n//        }\n//\n//        if (system.devBox.isSetNight && !system.getState(\"isSetNight\")) {\n//            system.setState(\"isSetNight\", true)\n//        }\n//        if (system.devBox.isShadowsEnabled && !system.getState(\"isEnableShadows\")) {\n//            system.addCommand(Commands.CreateShadows)\n//            system.setState(\"isEnableShadows\", true)\n//        }\n//\n//        // Remove commands\n//        if (!system.devBox.isEnableFreeCamera && system.getState(\"isEnableFreeCamera\")) {\n//            system.setState(\"isEnableFreeCamera\", false)\n//        }\n//\n//        if (!system.devBox.isEnablePhysics && system.getState(\"isEnablePhysics\")) {\n//            system.setState(\"isEnablePhysics\", false)\n//        }\n//\n//        if (!system.devBox.isSetNight && system.getState(\"isSetNight\")) {\n//            system.setState(\"isSetNight\", false)\n//        }\n//        if (!system.devBox.isShadowsEnabled && system.getState(\"isEnableShadows\")) {\n//            system.removeCommand(Commands.UpdateShadowNumber)\n//            system.removeCommand(Commands.UpdateShadowProperties)\n//            system.addCommand(Commands.RemoveShadows)\n//\n//            system.setState(\"isEnableShadows\", false)\n//        }\n//\n//    }\n//}\n//\n//// physics\n//export class ApplyForce implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.ApplyForce\n//    }\n//\n//    run(system: ECS.System) {\n//        let delta = system.delta()\n//        if (delta == null) return\n//\n//        let foundForceComponents = system.find(\n//            [ECS.Get.All, [Comps.Components.Force], ECS.By.Any, null])\n//        if (foundForceComponents[0].length == 0) {\n//            console.log(\"no force components\")\n//            return\n//        }\n//\n//        for (let fFC of foundForceComponents[0]) {\n//\n//            let foundPositionComponents = system.find(\n//                [ECS.Get.One, [Comps.Components.Position, Comps.Components.Mass], ECS.By.EntityId, fFC.component.entityUid])\n//            if (foundPositionComponents[0].length == 0 || foundPositionComponents[1].length == 0) {\n//                console.log(\"no position or mass component\")\n//                return\n//            }\n//\n//            let forceComponent = fFC.component as Comps.Force\n//            let positionComponent = foundPositionComponents[0][0].component as Comps.Position\n//            let massComponent = foundPositionComponents[1][0].component as Comps.Mass\n//\n//            let velocity = new Utils.Vector2(0, 0)\n//            let airDrag = 0.005\n//            let resultForce = new Utils.Vector2(0, 0)\n//\n//            // apply air drag\n//            if (forceComponent.x < 0) {\n//                velocity.x = forceComponent.x / massComponent.mass\n//                resultForce.x = forceComponent.x + airDrag\n//            }\n//            if (forceComponent.x > 0) {\n//                velocity.x = forceComponent.x / massComponent.mass\n//                resultForce.x = forceComponent.x - airDrag\n//            }\n//            if (forceComponent.y < 0) {\n//                velocity.y = forceComponent.y / massComponent.mass\n//                resultForce.y = forceComponent.y + airDrag\n//            }\n//            if (forceComponent.y > 0) {\n//                velocity.y = forceComponent.y / massComponent.mass\n//                resultForce.y = forceComponent.y - airDrag\n//            }\n//\n//            // make mass not invert velocity, ex. force < mass\n//            if (forceComponent.x > 0 && velocity.x < 0 || forceComponent.x < 0 && velocity.x > 0) {\n//                velocity.x = 0\n//            }\n//            if (forceComponent.y > 0 && velocity.y < 0 || forceComponent.y < 0 && velocity.y > 0) {\n//                velocity.y = 0\n//            }\n//\n//            // make force dont invert because of drag\n//            if (forceComponent.x > 0 && resultForce.x < 0 || forceComponent.x < 0 && resultForce.x > 0) {\n//                resultForce.x = 0\n//            }\n//            if (forceComponent.y > 0 && resultForce.y < 0 || forceComponent.y < 0 && resultForce.y > 0) {\n//                resultForce.y = 0\n//            }\n//\n//            //let airDrag = 0.001\n//            // for x\n//            if (velocity.x != 0) {\n//                system.setProperty<Comps.Position, \"x\">(\n//                    foundPositionComponents[0][0], \"x\", positionComponent.x + velocity.x * delta)\n//\n//                // forces always should always go towards 0\n//                system.setProperty<Comps.Force, \"x\">(\n//                    fFC, \"x\", resultForce.x)\n//            }\n//            // for y\n//            if (velocity.y != 0) {\n//                system.setProperty<Comps.Position, \"y\">(\n//                    foundPositionComponents[0][0], \"y\", positionComponent.y + velocity.y * delta)\n//\n//                system.setProperty<Comps.Force, \"y\">(\n//                    fFC, \"y\", resultForce.y)\n//            }\n//        }\n//    }\n//}\n//export class Collide implements ECS.Command {\n//    readonly type: Commands\n//    constructor() {\n//        this.type = Commands.Collide\n//    }\n//\n//    run(system: ECS.System, resources: Res.Resources) {\n//        for (let cFC of resources.componentChanges.changedComponents[Comps.Components.Force]) {\n//\n//            let giverFoundComponents = system.find(\n//                [ECS.Get.One, [Comps.Components.Position, Comps.Components.Size, Comps.Components.Mass], ECS.By.EntityId, cFC.component.entityUid])\n//            if (\n//                giverFoundComponents[0].length == 0 ||\n//                giverFoundComponents[1].length == 0 ||\n//                giverFoundComponents[2].length == 0\n//            ) {\n//                console.log(\"no giver components found\")\n//                continue\n//            }\n//\n//            let giverForceComponent = cFC as Comps.Force\n//            let giverPositionComponent = giverFoundComponents[0][0] as Comps.Position\n//            let giverSizeComponent = giverFoundComponents[1][0] as Comps.Size\n//            let giverMassComponent = giverFoundComponents[2][0] as Comps.Mass\n//\n//            let foundTakerSizeComponents = system.find(\n//                [ECS.Get.All, [Comps.Components.Size], ECS.By.Any, null])\n//\n//            for (let fSC of foundTakerSizeComponents[0]) {\n//                if (fSC.entityUid == cFC.entityUid) continue\n//                let foundTakerComponents = system.find(\n//                    [ECS.Get.One, [Comps.Components.Position, Comps.Components.Force, Comps.Components.Mass], ECS.By.EntityId, fSC.component.entityUid])\n//                if (foundTakerComponents[0].length == 0) {\n//                    console.log(\"no position found\")\n//                    continue\n//                }\n//                if (foundTakerComponents[1].length == 0) {\n//                    continue\n//                }\n//                let takerSizeComponent = fSC as Comps.Size\n//                let takerPositionComponent = foundTakerComponents[0][0] as Comps.Position\n//                let takerForceComponent = foundTakerComponents[1][0] as Comps.Force\n//                let takerMassComponent = foundTakerComponents[2][0] as Comps.Mass\n//\n//                // from, to\n//                let xRange1 = [\n//                    giverPositionComponent.x - giverSizeComponent.x / 2,\n//                    giverPositionComponent.x + giverSizeComponent.x / 2]\n//                let yRange1 = [\n//                    giverPositionComponent.y - giverSizeComponent.y / 2,\n//                    giverPositionComponent.y + giverSizeComponent.y / 2]\n//\n//                let xRange2 = [\n//                    takerPositionComponent.x - (takerSizeComponent.x / 2),\n//                    takerPositionComponent.x + (takerSizeComponent.x / 2)]\n//                let yRange2 = [\n//                    takerPositionComponent.y - (takerSizeComponent.y / 2),\n//                    takerPositionComponent.y + (takerSizeComponent.y / 2)]\n//\n//                let numberHitPoints = 0\n//                let touchingDirection = new Utils.Vector2(0, 0)\n//                if (\n//                    xRange1[1] >= xRange2[0] &&\n//                    !(xRange1[0] > xRange2[0]) &&\n//                    !(xRange1[0] == xRange2[0] && xRange1[1] == xRange2[1])\n//                ) {\n//                    numberHitPoints += 1\n//                    touchingDirection.x += 1\n//                }\n//                if (\n//                    xRange1[0] <= xRange2[1] &&\n//                    !(xRange1[1] < xRange2[1]) &&\n//                    !(xRange1[0] == xRange2[0] && xRange1[1] == xRange2[1])\n//                ) {\n//                    numberHitPoints += 1\n//                    touchingDirection.x -= 1\n//                }\n//                if (\n//                    yRange1[1] >= yRange2[0] &&\n//                    !(yRange1[0] > yRange2[0]) &&\n//                    !(yRange1[0] == yRange2[0] && yRange1[1] == yRange2[1])\n//                ) {\n//                    numberHitPoints += 1\n//                    touchingDirection.y += 1\n//                }\n//                if (\n//                    yRange1[0] <= yRange2[1] &&\n//                    !(yRange1[1] < yRange2[1]) &&\n//                    !(yRange1[0] == yRange2[0] && yRange1[1] == yRange2[1])\n//                ) {\n//                    numberHitPoints += 1\n//                    touchingDirection.y -= 1\n//                }\n//                if (yRange1[0] == yRange2[0] && yRange1[1] == yRange2[1]) {\n//                    numberHitPoints += 1\n//                }\n//                if (xRange1[0] == xRange2[0] && xRange1[1] == xRange2[1]) {\n//                    numberHitPoints += 1\n//                }\n//\n//                if (numberHitPoints < 2) continue\n//                let forceDirection = new Utils.Vector2(0, 0)\n//                if (giverForceComponent.x > 0) {\n//                    forceDirection.x += 1\n//                }\n//                if (giverForceComponent.y > 0) {\n//                    forceDirection.y += 1\n//                }\n//                if (giverForceComponent.x < 0) {\n//                    forceDirection.x -= 1\n//                }\n//                if (giverForceComponent.y < 0) {\n//                    forceDirection.y -= 1\n//                }\n//\n//                //if (takerMassComponent.mass == takerMassComponent.mass) {\n//                //    //skip\n//                //}\n//\n//                //let giverNewForce = new Utils.Vector2(0, 0)\n//                //let takerNewForce = new Utils.Vector2(0, 0)\n//\n//                //// one has more mass\n//                //if (giverMassComponent.mass != takerMassComponent.mass) {\n//                //    if (giverMassComponent.mass > takerMassComponent.mass) {\n//                //    }\n//                //}\n//                //// they are the same mass\n//                //if () { }\n//\n//                // console.log(forceDirection)\n//                // calculate force taken for moving it out of reach\n//                // substract force took for moving it\n//                if (forceDirection.x == touchingDirection.x && forceDirection.x != 0) {\n//                    system.setProperty<Comps.Force, \"x\">(\n//                        foundTakerComponents[1][0],\n//                        \"x\",\n//                        giverForceComponent.x + takerForceComponent.x)\n//                    system.setProperty<Comps.Force, \"x\">(cFC, \"x\", 0)\n//                    system.setProperty<Comps.Position, \"x\">(\n//                        giverFoundComponents[0][0],\n//                        \"x\",\n//                        giverPositionComponent.x - giverForceComponent.x)\n//                }\n//                if (forceDirection.y == touchingDirection.y && forceDirection.y != 0) {\n//                    system.setProperty<Comps.Force, \"y\">(\n//                        foundTakerComponents[1][0],\n//                        \"y\",\n//                        giverForceComponent.y + takerForceComponent.y)\n//                    system.setProperty<Comps.Force, \"y\">(cFC, \"y\", 0)\n//                    system.setProperty<Comps.Position, \"y\">(\n//                        giverFoundComponents[0][0],\n//                        \"y\",\n//                        giverPositionComponent.y - giverForceComponent.y)\n//                }\n//            }\n//        }\n//    }\n//}\n\n\n//# sourceURL=webpack://strworld/./src/commands.ts?");

/***/ }),

/***/ "./src/components.ts":
/*!***************************!*\
  !*** ./src/components.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera),\n/* harmony export */   ChangedGraphicProperties: () => (/* binding */ ChangedGraphicProperties),\n/* harmony export */   Components: () => (/* binding */ Components),\n/* harmony export */   EntityState: () => (/* binding */ EntityState),\n/* harmony export */   EntityStates: () => (/* binding */ EntityStates),\n/* harmony export */   EntityType: () => (/* binding */ EntityType),\n/* harmony export */   EntityTypes: () => (/* binding */ EntityTypes),\n/* harmony export */   Force: () => (/* binding */ Force),\n/* harmony export */   Health: () => (/* binding */ Health),\n/* harmony export */   Light: () => (/* binding */ Light),\n/* harmony export */   LightTypes: () => (/* binding */ LightTypes),\n/* harmony export */   Mass: () => (/* binding */ Mass),\n/* harmony export */   NUMBER_OF_COMPONENTS: () => (/* binding */ NUMBER_OF_COMPONENTS),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   Rotation: () => (/* binding */ Rotation),\n/* harmony export */   Size: () => (/* binding */ Size),\n/* harmony export */   TargetLocation: () => (/* binding */ TargetLocation),\n/* harmony export */   Timer: () => (/* binding */ Timer),\n/* harmony export */   TimerTypes: () => (/* binding */ TimerTypes)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\nvar Components;\n(function (Components) {\n    Components[Components[\"Health\"] = 0] = \"Health\";\n    Components[Components[\"Camera\"] = 1] = \"Camera\";\n    Components[Components[\"Light\"] = 2] = \"Light\";\n    Components[Components[\"Rotation\"] = 3] = \"Rotation\";\n    Components[Components[\"EntityState\"] = 4] = \"EntityState\";\n    Components[Components[\"Name\"] = 5] = \"Name\";\n    Components[Components[\"EntityType\"] = 6] = \"EntityType\";\n    Components[Components[\"Position\"] = 7] = \"Position\";\n    Components[Components[\"LookingDirection\"] = 8] = \"LookingDirection\";\n    Components[Components[\"ComputedElement\"] = 9] = \"ComputedElement\";\n    Components[Components[\"TargetLocation\"] = 10] = \"TargetLocation\";\n    Components[Components[\"Timer\"] = 11] = \"Timer\";\n    Components[Components[\"Size\"] = 12] = \"Size\";\n    Components[Components[\"Mass\"] = 13] = \"Mass\";\n    Components[Components[\"Force\"] = 14] = \"Force\";\n})(Components || (Components = {}));\nconst NUMBER_OF_COMPONENTS = (() => {\n    let n = 0;\n    for (let i = 0; i < Object.keys(Components).length / 2; i++) {\n        n++;\n    }\n    return n;\n})();\nvar EntityTypes;\n(function (EntityTypes) {\n    EntityTypes[EntityTypes[\"Stickman\"] = 0] = \"Stickman\";\n    EntityTypes[EntityTypes[\"Grass\"] = 1] = \"Grass\";\n    EntityTypes[EntityTypes[\"Dog\"] = 2] = \"Dog\";\n    EntityTypes[EntityTypes[\"Camera\"] = 3] = \"Camera\";\n    EntityTypes[EntityTypes[\"Light\"] = 4] = \"Light\";\n})(EntityTypes || (EntityTypes = {}));\nvar EntityStates;\n(function (EntityStates) {\n    EntityStates[EntityStates[\"Idle\"] = 0] = \"Idle\";\n    EntityStates[EntityStates[\"Run\"] = 1] = \"Run\";\n    EntityStates[EntityStates[\"Follow\"] = 2] = \"Follow\";\n    EntityStates[EntityStates[\"Attack\"] = 3] = \"Attack\";\n    EntityStates[EntityStates[\"Chase\"] = 4] = \"Chase\";\n})(EntityStates || (EntityStates = {}));\nvar LightTypes;\n(function (LightTypes) {\n    LightTypes[LightTypes[\"AmbientLight\"] = 0] = \"AmbientLight\";\n    LightTypes[LightTypes[\"PointLight\"] = 1] = \"PointLight\";\n    LightTypes[LightTypes[\"DirectionalLight\"] = 2] = \"DirectionalLight\";\n    LightTypes[LightTypes[\"SpotLight\"] = 3] = \"SpotLight\";\n})(LightTypes || (LightTypes = {}));\nclass Light {\n    constructor(newLightType, newPower, newColor, newDistance, newDecay, newEntityUid) {\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Light;\n        this.lightType = newLightType;\n        this.power = newPower;\n        this.color = newColor;\n        this.distance = newDistance;\n        this.decay = newDecay;\n    }\n}\nclass Camera {\n    constructor(newFov, newNear, newFar, newAspect, newEntityUid) {\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Camera;\n        this.fov = newFov;\n        this.near = newNear;\n        this.far = newFar;\n        this.aspect = newAspect;\n    }\n}\nclass TargetLocation {\n    constructor(newLocation, newEntityUid) {\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.TargetLocation;\n        this.x = newLocation.x;\n        this.y = newLocation.y;\n    }\n}\nclass EntityType {\n    constructor(newEntityType, newEntityUid) {\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.EntityType;\n        this.entityType = newEntityType;\n    }\n}\nclass EntityState {\n    constructor(newState, newEntityUid) {\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.EntityState;\n        this.states = newState;\n    }\n}\nclass Position {\n    constructor(newPosition, newEntityUid) {\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Position;\n        this.x = newPosition.x;\n        this.y = newPosition.y;\n        this.z = newPosition.z;\n    }\n}\nclass Health {\n    constructor(newHealth, newEntityUid) {\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Health;\n        this.health = newHealth;\n    }\n}\n//export class Animation implements ECS.Component {\n//    entityUid: number\n//    componentUid: number\n//    type: Components\n//    currentDisplayElement: string\n//    animations: Anims.Animation[]\n//\n//    constructor(newAnimations: Anims.Animation[], newEntityUid: number) {\n//        this.componentUid = Utils.newUid()\n//        this.entityUid = newEntityUid\n//        this.type = Components.Animation\n//        this.currentDisplayElement = \"?\"\n//        this.animations = newAnimations\n//    }\n//}\nclass Force {\n    constructor(newMomentum, newEntityUid) {\n        this.x = newMomentum.x;\n        this.y = newMomentum.y;\n        this.z = newMomentum.z;\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Force;\n    }\n}\nclass Mass {\n    constructor(newMass, newEntityUid) {\n        this.mass = newMass;\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Mass;\n    }\n}\nclass Rotation {\n    constructor(newRotation, newEntityUid) {\n        this.x = newRotation.x;\n        this.y = newRotation.y;\n        this.z = newRotation.z;\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Size;\n    }\n}\nclass Size {\n    constructor(newSize, newEntityUid) {\n        this.x = newSize.x;\n        this.y = newSize.y;\n        this.z = newSize.z;\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Size;\n    }\n}\nvar TimerTypes;\n(function (TimerTypes) {\n    TimerTypes[TimerTypes[\"Animation\"] = 0] = \"Animation\";\n})(TimerTypes || (TimerTypes = {}));\nclass Timer {\n    constructor(newTimeLeft, newTimerType, newEntityUid) {\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n        this.entityUid = newEntityUid;\n        this.type = Components.Timer;\n        this.isFinished = false;\n        this.isRestart = false;\n        this.timeLeft = newTimeLeft;\n        this.originalTime = newTimeLeft;\n        this.timerType = newTimerType;\n    }\n}\nclass ChangedGraphicProperties {\n    constructor(newEntityUid) {\n        this.properties = [];\n        this.type = Components.ComputedElement;\n        this.entityUid = newEntityUid;\n        this.componentUid = _utils__WEBPACK_IMPORTED_MODULE_0__.newUid();\n    }\n}\n\n\n//# sourceURL=webpack://strworld/./src/components.ts?");

/***/ }),

/***/ "./src/ecs.ts":
/*!********************!*\
  !*** ./src/ecs.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   By: () => (/* binding */ By),\n/* harmony export */   CurrentExecutingCommand: () => (/* binding */ CurrentExecutingCommand),\n/* harmony export */   Get: () => (/* binding */ Get),\n/* harmony export */   System: () => (/* binding */ System)\n/* harmony export */ });\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components */ \"./src/components.ts\");\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commands */ \"./src/commands.ts\");\n\n\nvar Get;\n(function (Get) {\n    Get[Get[\"One\"] = 0] = \"One\";\n    Get[Get[\"All\"] = 1] = \"All\";\n})(Get || (Get = {}));\nvar By;\n(function (By) {\n    By[By[\"EntityId\"] = 0] = \"EntityId\";\n    By[By[\"EntityType\"] = 1] = \"EntityType\";\n    By[By[\"ComponentId\"] = 2] = \"ComponentId\";\n    By[By[\"Any\"] = 3] = \"Any\";\n})(By || (By = {}));\nclass CommandChanges {\n    constructor() {\n        this.removedCommands = [];\n        this.addedCommands = [];\n    }\n    clearChanges() {\n        this.removedCommands = [];\n        this.addedCommands = [];\n    }\n}\nclass CurrentExecutingCommand {\n    constructor() {\n        this.command = null;\n    }\n}\nclass System {\n    constructor(newResources, newCurrentExecutingCommand) {\n        this.accessedComponent = null;\n        this.resources = newResources;\n        this.currentExecutingCommand = newCurrentExecutingCommand;\n        this.commandChangesBuffer = new CommandChanges();\n        this.commands = [];\n        this.components = [];\n        for (let _ = 0; _ < _components__WEBPACK_IMPORTED_MODULE_0__.NUMBER_OF_COMPONENTS; _++) {\n            this.components.push([]);\n        }\n    }\n    removeCommand(command) {\n        this.commandChangesBuffer.removedCommands.push(command);\n    }\n    addComponent(component) {\n        this.components[component.type].push(this.createProxy(component));\n        this\n            .resources\n            .componentChanges\n            .addedComponentsBuffer[component.type]\n            .push(component);\n    }\n    removeComponent(component) {\n        for (let [cI, c] of this.components[component.type].entries()) {\n            if (c.componentUid == component.componentUid) {\n                this\n                    .resources\n                    .componentChanges\n                    .removedComponentsBuffer[component.type]\n                    .push(component);\n                this.components.splice(cI, 1);\n            }\n        }\n    }\n    createProxy(obj) {\n        let outer = this;\n        let handler = {\n            set(obj, prop, value) {\n                if (\"componentUid\" in obj) {\n                    outer.accessedComponent = obj;\n                }\n                let isAlreadyChanged = false;\n                for (let cC of outer\n                    .resources\n                    .componentChanges\n                    .changedComponentsBuffer[outer.accessedComponent.type]) {\n                    if (cC.componentUid == outer.accessedComponent.componentUid) {\n                        isAlreadyChanged = true;\n                    }\n                }\n                if (!isAlreadyChanged) {\n                    outer\n                        .resources\n                        .componentChanges\n                        .changedComponentsBuffer[outer.accessedComponent.type]\n                        .push(outer.accessedComponent);\n                }\n                obj[prop] = value;\n                return true;\n            },\n            get(obj, prop) {\n                if (\"componentUid\" in obj) {\n                    outer.accessedComponent = obj;\n                }\n                if (typeof obj[prop] == \"object\") {\n                    return outer.createProxy(obj[prop]);\n                }\n                return obj[prop];\n            },\n        };\n        return new Proxy(obj, handler);\n    }\n    addCommand(command) {\n        this.commandChangesBuffer.addedCommands.push(command);\n    }\n    find(query) {\n        // Comment on production !TODO\n        if (query[1].length == 0) {\n            console.log(\"no components expecified\");\n            return [];\n        }\n        if (query[2] == By.EntityType && query[3] == undefined ||\n            query[2] == By.ComponentId && typeof query[3] != \"number\" ||\n            query[2] == By.EntityId && typeof query[3] != \"number\") {\n            console.log('argument does not match \"By\" enum');\n            return [];\n        }\n        if (query[0] == Get.All && query[2] == By.ComponentId) {\n            console.log('cannot get all by component id');\n            return [];\n        }\n        if (query[0] == Get.One && query[2] == By.EntityType) {\n            console.log(\"query Get.One By.EntityType is not supported yet\");\n            return [];\n        }\n        if (query[0] == Get.One && query[2] == By.Any) {\n            console.log(\"query Get.One By.Any is not supported yet\");\n            return [];\n        }\n        // Comment on production !TODO\n        let collected = [];\n        for (let i = 0; i < query[1].length; i++) {\n            collected.push([]);\n        }\n        for (let [qci, qc] of query[1].entries()) {\n            if (query[0] == Get.One) {\n                if (query[2] == By.ComponentId) {\n                    for (let c of this.components[qc]) {\n                        if (query[3] == c.componentUid) {\n                            collected[qci].push(c);\n                            break;\n                        }\n                    }\n                    continue;\n                }\n                else if (query[2] == By.EntityId) {\n                    for (let c of this.components[qc]) {\n                        if (query[3] == c.entityUid) {\n                            collected[qci].push(c);\n                            break;\n                        }\n                    }\n                    continue;\n                }\n            }\n            else if (query[0] == Get.All) {\n                if (query[2] == By.EntityId) {\n                    for (let c of this.components[qc]) {\n                        if (query[3] == c.entityUid) {\n                            collected[qci].push(c);\n                        }\n                    }\n                    continue;\n                }\n                else if (query[2] == By.Any) {\n                    for (let c of this.components[qc]) {\n                        collected[qci].push(c);\n                    }\n                    continue;\n                }\n                //                else if (query[2] == By.EntityType) {\n                //                    for (let e of this.components[Comps.Components.EntityType]) {\n                //                        if (query[3] == e.entityType) {\n                //                            for (let c of this.components[qc]) {\n                //                                if (e.entityUid == c.ownerUid) {\n                //                                    collected[qci].push(c)\n                //                                }\n                //                            }\n                //                            break;\n                //                        }\n                //                    }\n                //                    continue;\n                //                }\n            }\n        }\n        return collected;\n    }\n    updateCommands() {\n        for (let aC of this.commandChangesBuffer.addedCommands) {\n            let isFound = false;\n            for (let c of this.commands) {\n                if (aC == c.type) {\n                    console.log(\"$ command already exists\");\n                    isFound = true;\n                }\n            }\n            if (isFound) {\n                continue;\n            }\n            let command = _commands__WEBPACK_IMPORTED_MODULE_1__.getInstanceFromEnum(aC);\n            let isInserted = false;\n            for (let [cI, c] of this.commands.entries()) {\n                if (aC < c.type) {\n                    isInserted = true;\n                    this.commands.splice(cI, 0, command);\n                }\n            }\n            if (!isInserted) {\n                this.commands.push(command);\n            }\n        }\n        for (let rC of this.commandChangesBuffer.removedCommands) {\n            let isFound = false;\n            for (let cI = this.commands.length - 1; cI >= 0; cI--) {\n                if (rC == this.commands[cI].type) {\n                    isFound = true;\n                    this.commands.splice(cI, 1);\n                    this.resources.commandState.removeCommandStates(rC);\n                }\n            }\n            if (!isFound) {\n                console.log(\"$ command was not found\");\n            }\n        }\n    }\n    run() {\n        for (let c of this.commands) {\n            this.currentExecutingCommand.command = c.type;\n            c.run(this, this.resources);\n        }\n        this.updateCommands();\n        this.commandChangesBuffer.clearChanges();\n        this.resources.componentChanges.cycleChanges();\n    }\n}\n\n\n//# sourceURL=webpack://strworld/./src/ecs.ts?");

/***/ }),

/***/ "./src/resources.ts":
/*!**************************!*\
  !*** ./src/resources.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandStateResource: () => (/* binding */ CommandStateResource),\n/* harmony export */   ComponentChanges: () => (/* binding */ ComponentChanges),\n/* harmony export */   ConfigurationResource: () => (/* binding */ ConfigurationResource),\n/* harmony export */   DeltaResource: () => (/* binding */ DeltaResource),\n/* harmony export */   InputResource: () => (/* binding */ InputResource),\n/* harmony export */   IsFirstTimeResource: () => (/* binding */ IsFirstTimeResource),\n/* harmony export */   Resources: () => (/* binding */ Resources)\n/* harmony export */ });\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components */ \"./src/components.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\nclass Resources {\n    constructor(newCurrentExecutingCommand) {\n        this.delta = new DeltaResource(newCurrentExecutingCommand);\n        this.isFirstTime = new IsFirstTimeResource(newCurrentExecutingCommand);\n        this.commandState = new CommandStateResource(newCurrentExecutingCommand);\n        this.componentChanges = new ComponentChanges();\n        this.input = new InputResource();\n        this.configuration = new ConfigurationResource();\n    }\n}\nclass LastTimeCommandWasRun {\n    constructor(newTime, newCommand) {\n        this.time = newTime;\n        this.command = newCommand;\n    }\n}\nclass DeltaResource {\n    constructor(newCurrentExecutingCommand) {\n        this.currentExecutingCommand = newCurrentExecutingCommand;\n        this.lastTimeCommandsWereRun = [];\n    }\n    get() {\n        for (let d of this.lastTimeCommandsWereRun) {\n            if (d.command == this.currentExecutingCommand.command) {\n                let oldTime = d.time;\n                d.time = performance.now();\n                return performance.now() - oldTime;\n            }\n        }\n        this.lastTimeCommandsWereRun.push(new LastTimeCommandWasRun(performance.now(), this.currentExecutingCommand.command));\n        return null;\n    }\n}\nclass CommandStateResource {\n    constructor(newCurrentExecutingCommand) {\n        this.currentExecutingCommand = newCurrentExecutingCommand;\n        this.state = new Map();\n    }\n    removeCommandStates(command) {\n        for (let [k, _] of this.state) {\n            if (k[1] == command) {\n                this.state.delete(k);\n            }\n        }\n    }\n    set(key, value) {\n        this.state.set([key, this.currentExecutingCommand.command], value);\n    }\n    get(key) {\n        console.log(this.state);\n        let value = this.state.get([key, this.currentExecutingCommand.command]);\n        if (value == undefined) {\n            return null;\n        }\n        else {\n            return value[1];\n        }\n    }\n}\nclass IsFirstTimeResource {\n    constructor(newCurrentExecutingCommand) {\n        this.currentExecutingCommand = newCurrentExecutingCommand;\n        this.commandsCheckedFirstTime = [];\n    }\n    get() {\n        for (let cFT of this.commandsCheckedFirstTime) {\n            if (cFT == this.currentExecutingCommand.command) {\n                return false;\n            }\n        }\n        this.commandsCheckedFirstTime.push(this.currentExecutingCommand.command);\n        return true;\n    }\n}\nclass ConfigurationResource {\n    constructor() {\n        this.isSetNight = null;\n        this.isShadowsEnabled = null;\n        this.isEnablePhysics = null;\n        this.isEnableFreeCamera = null;\n    }\n}\nclass InputResource {\n    constructor() {\n        this.movementDirection = new _utils__WEBPACK_IMPORTED_MODULE_1__.Vector2(0, 0);\n    }\n}\nclass ComponentChanges {\n    constructor() {\n        this.baseStructure = [];\n        for (let i = 0; i < _components__WEBPACK_IMPORTED_MODULE_0__.NUMBER_OF_COMPONENTS; i++) {\n            this.baseStructure.push([]);\n        }\n        this.changedComponentsBuffer = structuredClone(this.baseStructure);\n        this.removedComponentsBuffer = structuredClone(this.baseStructure);\n        this.addedComponentsBuffer = structuredClone(this.baseStructure);\n        this.changedComponents = [];\n        this.removedComponents = [];\n        this.addedComponents = [];\n    }\n    cycleChanges() {\n        this.changedComponents = this.changedComponentsBuffer;\n        this.removedComponents = this.removedComponentsBuffer;\n        this.addedComponents = this.addedComponentsBuffer;\n        this.changedComponentsBuffer = structuredClone(this.baseStructure);\n        this.removedComponentsBuffer = structuredClone(this.baseStructure);\n        this.addedComponentsBuffer = structuredClone(this.baseStructure);\n    }\n}\n\n\n//# sourceURL=webpack://strworld/./src/resources.ts?");

/***/ }),

/***/ "./src/serialization.ts":
/*!******************************!*\
  !*** ./src/serialization.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GraphicChanges: () => (/* binding */ GraphicChanges),\n/* harmony export */   Input: () => (/* binding */ Input),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   Messages: () => (/* binding */ Messages),\n/* harmony export */   Options: () => (/* binding */ Options)\n/* harmony export */ });\nclass Options {\n    constructor(newIsShadowsEnabled, newIsSetNight, newIsEnablePhysics, newIsEnableFreeCamera) {\n        this.isShadowsEnabled = newIsShadowsEnabled;\n        this.isSetNight = newIsSetNight;\n        this.isEnablePhysics = newIsEnablePhysics;\n        this.isEnableFreeCamera = newIsEnableFreeCamera;\n    }\n}\nclass Input {\n    constructor(newMovementDirection) {\n        this.movementDirection = newMovementDirection;\n    }\n}\nclass GraphicChanges {\n    constructor() {\n        this.changedGraphicProperties = [];\n        this.addedGraphicProperties = [];\n        this.removedGraphicProperties = [];\n    }\n}\nvar Messages;\n(function (Messages) {\n    Messages[Messages[\"Start\"] = 0] = \"Start\";\n    Messages[Messages[\"Input\"] = 1] = \"Input\";\n    Messages[Messages[\"Options\"] = 2] = \"Options\";\n    Messages[Messages[\"GraphicChanges\"] = 3] = \"GraphicChanges\";\n})(Messages || (Messages = {}));\nclass Message {\n    constructor(newMessage, newData = null) {\n        this.message = newMessage;\n        this.data = newData;\n    }\n}\n\n\n//# sourceURL=webpack://strworld/./src/serialization.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssetFetchCache: () => (/* binding */ AssetFetchCache),\n/* harmony export */   Vector2: () => (/* binding */ Vector2),\n/* harmony export */   Vector3: () => (/* binding */ Vector3),\n/* harmony export */   newUid: () => (/* binding */ newUid),\n/* harmony export */   randomNumber: () => (/* binding */ randomNumber),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst randomNumber = (max) => Math.floor(Math.random() * max) + 1;\nconst newUid = () => randomNumber(100000000);\nconst sleep = (ms) => new Promise((r) => setTimeout(r, ms));\nclass AssetFetchCache {\n    static fetch(assetName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let asset = this.cachedAssets.get(assetName);\n            if (asset == undefined) {\n                let fetchedAsset = yield (yield fetch(\"assets/\" + assetName)).blob();\n                this.cachedAssets.set(assetName, fetchedAsset);\n                return fetchedAsset;\n            }\n            return asset;\n        });\n    }\n}\nAssetFetchCache.cachedAssets = new Map();\nclass Vector2 {\n    constructor(newX, newY) {\n        this.x = newX;\n        this.y = newY;\n    }\n}\nclass Vector3 {\n    constructor(newX, newY, newZ) {\n        this.x = newX;\n        this.y = newY;\n        this.z = newZ;\n    }\n}\n\n\n//# sourceURL=webpack://strworld/./src/utils.ts?");

/***/ }),

/***/ "./src/worker.ts":
/*!***********************!*\
  !*** ./src/worker.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ecs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ecs */ \"./src/ecs.ts\");\n/* harmony import */ var _serialization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serialization */ \"./src/serialization.ts\");\n/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resources */ \"./src/resources.ts\");\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commands */ \"./src/commands.ts\");\n\n\n\n\nlet currentExecutingCommand = new _ecs__WEBPACK_IMPORTED_MODULE_0__.CurrentExecutingCommand();\nlet resources = new _resources__WEBPACK_IMPORTED_MODULE_2__.Resources(currentExecutingCommand);\nlet system = new _ecs__WEBPACK_IMPORTED_MODULE_0__.System(resources, currentExecutingCommand);\nonmessage = (data) => {\n    let msg = data.data;\n    switch (msg.message) {\n        case _serialization__WEBPACK_IMPORTED_MODULE_1__.Messages.Start:\n            {\n                system.addCommand(_commands__WEBPACK_IMPORTED_MODULE_3__.Commands.TheFirst);\n                setInterval(system.run.bind(system), 100);\n            }\n            break;\n        case _serialization__WEBPACK_IMPORTED_MODULE_1__.Messages.Input:\n            {\n                let newData = msg.data;\n                resources.input.movementDirection = newData.movementDirection;\n            }\n            break;\n        case _serialization__WEBPACK_IMPORTED_MODULE_1__.Messages.Options:\n            {\n                let newData = msg.data;\n            }\n            break;\n    }\n};\n\n\n//# sourceURL=webpack://strworld/./src/worker.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/worker.ts");
/******/ 	
/******/ })()
;